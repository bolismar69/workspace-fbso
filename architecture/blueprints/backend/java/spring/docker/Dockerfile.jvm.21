# syntax=docker/dockerfile:1.7
ARG IMAGE_TO_BUILD=eclipse-temurin:21-jdk-jammy
ARG IMAGE_TO_RUNTIME=eclipse-temurin:21-jre-jammy

FROM ${IMAGE_TO_BUILD} AS build
ARG CMD_EXTRA_BUILDER_PRE_COPY=""
ARG CMD_EXTRA_BUILDER_POS_COMPILE=""

WORKDIR /workspace

RUN set -eux; \
  if [ -n "${CMD_EXTRA_BUILDER_PRE_COPY:-}" ]; then sh -lc "${CMD_EXTRA_BUILDER_PRE_COPY}"; fi

# 1) Camada: arquivos de build
COPY pom.xml ./
COPY .mvn/ .mvn/
COPY mvnw ./

# 2) Aquece deps
RUN --mount=type=cache,target=/root/.m2 \
    set -eux; \
    if [ -x ./mvnw ]; then ./mvnw -q -DskipTests dependency:go-offline || true; else echo "ERRO: mvnw ausente" && exit 1; fi

# 3) Código
COPY . .

# 4) Build final
RUN --mount=type=cache,target=/root/.m2 \
    set -eux; \
    ./mvnw -q -DskipTests package; \
    cp "$(ls -1 target/*.jar | head -n 1)" /workspace/app.jar

RUN set -eux; \
  # (ex: mvn clean package ...)
  if [ -n "${CMD_EXTRA_BUILDER_POS_COMPILE:-}" ]; then sh -lc "${CMD_EXTRA_BUILDER_POS_COMPILE}"; fi

FROM ${IMAGE_TO_RUNTIME} AS runtime
ARG APP_PORT=8080
ARG APP_USER=10001
ARG CMD_EXTRA_RUNTIME_PRE_COPY=""
ARG CMD_EXTRA_RUNTIME_PRE_CMD=""

ENV APP_PORT=${APP_PORT}

WORKDIR /app

RUN set -eux; \
  if [ -n "${CMD_EXTRA_RUNTIME_PRE_COPY:-}" ]; then sh -lc "${CMD_EXTRA_RUNTIME_PRE_COPY}"; fi

COPY --from=build /workspace/app.jar /app/app.jar

RUN set -eux; \
  if [ -n "${CMD_EXTRA_RUNTIME_PRE_CMD:-}" ]; then sh -lc "${CMD_EXTRA_RUNTIME_PRE_CMD}"; fi

RUN set -eux; \
  useradd -r -u "${APP_USER}" -g root appuser; \
  chown -R "${APP_USER}":0 /app
USER ${APP_USER}

EXPOSE ${APP_PORT}
# Spring costuma respeitar SERVER_PORT/server.port; deixamos via env + JAVA_OPTS para ser flexível
ENTRYPOINT ["sh","-c","exec java $JAVA_OPTS -Dserver.port=$APP_PORT -jar /app/app.jar"]
