name: Java CI/CD Trigger

# Este workflow detecta mudanças em serviços Java dentro do monorepo
# e aciona um workflow reutilizável para compilar os serviços e publicar
# imagens Docker (build e push) quando aplicável.
#
# Expected output from `detect_services` step (JSON array):
# [ { "path": "backend/java/quarkus/ms-user-auth", "goals": "clean install" }, ... ]

on:
  push:
    branches: [ main ]
    paths:
      - 'backend/java/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'backend/java/**'
  workflow_dispatch:
    inputs:
      services:
        description: 'Opcional: JSON array de objetos {"path":"","goals":""} para sobrescrever a detecção automática'
        required: false

permissions:
  contents: read
  pull-requests: read
  packages: write

concurrency:
  group: java-ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  detect_services:
    name: Detectar serviços Java alterados
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.extract.outputs.matrix }}

    steps:
      - name: Checkout do repositório
        id: checkout
        uses: actions/checkout@v4

      - name: Detectar serviços afetados
        id: extract
        uses: actions/github-script@v7
        with:
          script: |
            const servicesInputRaw = (context.payload?.inputs?.services ?? '').toString().trim();

            // Override manual via workflow_dispatch input (JSON array)
            if (servicesInputRaw && servicesInputRaw !== 'null') {
              core.info('Validando JSON de entrada (override via workflow_dispatch)...');
              let parsed;
              try {
                parsed = JSON.parse(servicesInputRaw);
              } catch (err) {
                core.setFailed("Erro: input 'services' não é JSON válido");
                return;
              }
              if (!Array.isArray(parsed)) {
                core.setFailed("Erro: input 'services' deve ser um JSON array");
                return;
              }
              core.info('Usando override de serviços via workflow_dispatch');

              // Deduplicar por path (mantém a primeira ocorrência; avisa se houver duplicadas)
              const seenPaths = new Set();
              const deduped = [];
              for (const entry of parsed) {
                const path = (entry?.path ?? '').toString().trim();
                if (!path) continue;
                if (seenPaths.has(path)) {
                  core.warning(`Entrada duplicada ignorada no input.services: ${path}`);
                  continue;
                }
                seenPaths.add(path);
                deduped.push({
                  path,
                  goals: (entry?.goals ?? 'clean install').toString(),
                });
              }

              core.setOutput('matrix', JSON.stringify(deduped));
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            let changedFiles = [];
            if (context.eventName === 'pull_request') {
              const prNumber = context.payload.pull_request.number;
              core.info(`Listando arquivos do PR #${prNumber} via API...`);
              const prFiles = await github.paginate(github.rest.pulls.listFiles, {
                owner,
                repo,
                pull_number: prNumber,
                per_page: 100,
              });
              changedFiles = prFiles.map(f => f.filename);
            } else if (context.eventName === 'push') {
              const base = context.payload.before;
              const head = context.sha;

              // Se for o primeiro push da branch (before = 0000...), usa fallback via payload.commits
              if (!base || /^0+$/.test(base)) {
                core.info('Push inicial detectado; usando lista de arquivos do payload de commits.');
                const commits = context.payload.commits ?? [];
                changedFiles = commits.flatMap(c => [
                  ...(c.added ?? []),
                  ...(c.modified ?? []),
                  ...(c.removed ?? []),
                ]);
              } else {
                core.info(`Comparando commits via API (${base}...${head})...`);
                const compare = await github.rest.repos.compareCommitsWithBasehead({
                  owner,
                  repo,
                  basehead: `${base}...${head}`,
                });
                changedFiles = (compare.data.files ?? []).map(f => f.filename);
              }
            } else {
              core.info(`Evento '${context.eventName}' não suportado para detecção automática; matrix vazia.`);
              changedFiles = [];
            }

            core.info(`Arquivos modificados: ${changedFiles.length}`);
            if (changedFiles.length > 0) {
              core.info(`Lista de arquivos modificados:\n${changedFiles.join('\n')}`);
            }

            // Extrair serviços únicos (assumindo estrutura backend/java/<framework>/<service>/...)
            // Remove duplicidades quando múltiplos arquivos mudam no mesmo serviço.
            const serviceSet = new Set();
            for (const filenameRaw of changedFiles) {
              const filename = (filenameRaw ?? '').toString();
              if (!filename.startsWith('backend/java/')) continue;
              const parts = filename.split('/');
              if (parts.length >= 4) {
                serviceSet.add(parts.slice(0, 4).join('/'));
              } else if (parts.length >= 3) {
                serviceSet.add(parts.slice(0, 3).join('/'));
              }
            }

            const services = Array.from(serviceSet).sort();
            core.info(`Serviços detectados: ${services.length}`);
            if (services.length > 0) {
              core.info(`Lista de serviços detectados:\n${services.join('\n')}`);
            }

            const matrix = services.map(p => ({ path: p, goals: 'clean install' }));
            core.setOutput('matrix', JSON.stringify(matrix));

  build_matrix:
    name: Build dos serviços Java
    needs: detect_services
    if: ${{ needs.detect_services.outputs.matrix != '[]' && needs.detect_services.outputs.matrix != '' }}
    uses: ./.github/workflows/build-java-service.yml
    with:
      services: ${{ needs.detect_services.outputs.matrix }}
    secrets:
      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
