name: Java CI/CD Trigger

# Este workflow detecta mudanças em serviços Java dentro do monorepo
# e aciona um workflow reutilizável para compilar os serviços e publicar
# imagens Docker (build e push) quando aplicável.
#
# Expected output passed to build reusable (JSON array):
# [
#   {
#     "path": "backend/java/...",
#     "goals": "clean install",
#     "platformVersion": "21",
#     "platformDistributor": "temurin"
#   }
# ]

on:
  push:
    branches: [ main ]
    paths:
      - 'backend/java/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'backend/java/**'
  workflow_dispatch:
    inputs:
      services:
        description: 'Opcional: JSON array de objetos {"path":"","goals":""} para sobrescrever a detecção automática'
        required: false

permissions:
  contents: read
  pull-requests: read
  packages: write

concurrency:
  group: java-ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  detect_solutions:
    name: Detectar solutions alteradas (monorepo)
    if: ${{ github.event_name == 'pull_request' || github.event_name == 'push' }}
    uses: ./.github/workflows/global_detection_solutions_changed.yml
    with:
      base_sha: ${{ github.event_name == 'pull_request' && github.event.pull_request.base.sha || github.event.before }}
      head_sha: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.sha || github.sha }}

  prepare_services:
    name: Preparar matrix de serviços Java
    runs-on: ubuntu-latest
    needs: [detect_solutions]
    if: ${{ always() }}
    outputs:
      matrix: ${{ steps.out.outputs.matrix }}
    steps:
      - name: Preparar lista de serviços para build
        id: out
        uses: actions/github-script@v7
        env:
          OVERRIDE: ${{ github.event.inputs.services }}
          SOLUTIONS_JSON: ${{ needs.detect_solutions.outputs.solutions }}
        with:
          script: |
            const overrideRaw = (process.env.OVERRIDE ?? '').toString().trim();

            // Override manual via workflow_dispatch input (JSON array)
            if (overrideRaw && overrideRaw !== 'null') {
              core.info('Validando JSON de entrada (override via workflow_dispatch)...');
              let parsed;
              try {
                parsed = JSON.parse(overrideRaw);
              } catch (err) {
                core.setFailed("Erro: input 'services' não é JSON válido");
                return;
              }
              if (!Array.isArray(parsed)) {
                core.setFailed("Erro: input 'services' deve ser um JSON array");
                return;
              }

              const seenPaths = new Set();
              const deduped = [];
              for (const entry of parsed) {
                const path = (entry?.path ?? '').toString().trim();
                if (!path) continue;

                if (seenPaths.has(path)) {
                  core.warning(`Entrada duplicada ignorada no input.services: ${path}`);
                  continue;
                }
                seenPaths.add(path);

                deduped.push({
                  path,
                  goals: (entry?.goals ?? 'clean install').toString(),
                  platformVersion: (entry?.platformVersion ?? '21').toString(),
                  platformDistributor: (entry?.platformDistributor ?? 'temurin').toString(),
                });
              }

              core.setOutput('matrix', JSON.stringify(deduped));
              return;
            }

            const solutionsRaw = (process.env.SOLUTIONS_JSON ?? '').toString().trim() || '[]';
            let solutions = [];
            try {
              solutions = JSON.parse(solutionsRaw);
            } catch (err) {
              core.warning('Falha ao parsear SOLUTIONS_JSON; assumindo []');
              solutions = [];
            }

            const services = (Array.isArray(solutions) ? solutions : [])
              .filter(s => s?.stack === 'backend' && s?.platform === 'java')
              .map(s => ({
                path: s.path,
                goals: 'clean install',
                platformVersion: (s?.platformVersion ?? '21').toString(),
                platformDistributor: (s?.platformDistributor ?? 'temurin').toString(),
              }));

            core.info(`Serviços Java preparados: ${services.length}`);
            listServices = services.map(s => `- ${s.path} (Java ${s.platformDistributor} ${s.platformVersion}, goals: ${s.goals})`).join('\n');
            core.info(`Lista de serviços:\n${listServices}`);
            core.setOutput('matrix', JSON.stringify(services));

  build_matrix:
    name: Build dos serviços Java
    needs: prepare_services
    if: ${{ needs.prepare_services.outputs.matrix != '[]' && needs.prepare_services.outputs.matrix != '' }}
    uses: ./.github/workflows/java-reusable-build-solutions.yml
    with:
      services: ${{ needs.prepare_services.outputs.matrix }}
    secrets:
      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
