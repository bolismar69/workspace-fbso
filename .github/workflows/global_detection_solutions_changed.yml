name: global_detection_solutions_changed

on:
  workflow_call:
    inputs:
      base_sha:
        description: "Base commit SHA (optional). If empty, inferred from event."
        required: false
        type: string
      head_sha:
        description: "Head commit SHA (optional). If empty, inferred from event."
        required: false
        type: string
    outputs:
      solutions:
        description: "JSON array of discovered modified solutions with metadata."
        value: ${{ jobs.detect_services.outputs.solutions }}
      paths:
        description: "JSON array of modified solution paths."
        value: ${{ jobs.detect_services.outputs.paths }}

jobs:
  detect_services:
    runs-on: ubuntu-latest
    outputs:
      solutions: ${{ steps.emit.outputs.solutions }}
      paths: ${{ steps.emit.outputs.paths }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect modified backend/frontend solutions
        id: emit
        shell: bash
        run: |
          set -euo pipefail

          # Resolve base/head SHAs (prefer inputs, fallback to event)
          BASE="${{ inputs.base_sha }}"
          HEAD="${{ inputs.head_sha }}"

          if [[ -z "${BASE}" || -z "${HEAD}" ]]; then
            if [[ "${{ github.event_name }}" == "pull_request" ]]; then
              BASE="${BASE:-${{ github.event.pull_request.base.sha }}}"
              HEAD="${HEAD:-${{ github.event.pull_request.head.sha }}}"
            else
              BASE="${BASE:-${{ github.event.before }}}"
              HEAD="${HEAD:-${{ github.sha }}}"
            fi
          fi

          echo "Using BASE=$BASE"
          echo "Using HEAD=$HEAD"

          # Ensure commits exist locally
          git fetch --no-tags --prune --depth=0 origin || true

          mapfile -t CHANGED < <(git diff --name-only "$BASE" "$HEAD" || true)

          # Build JSON array of solutions by parsing paths.
          # Canonical backend:
          #   backend/{platform}/{framework}/{type}/{solutionName}/...
          # Canonical frontend:
          #   frontend/{platform}/{type}/{solutionName}/...
          # When frontend has no distinct framework segment, we set framework=platform.
          declare -A ROOTS=()
          solutions_json="[]"
          paths_json="[]"

          for f in "${CHANGED[@]:-}"; do
            # backend/{platform}/{framework}/{type}/{solutionName}/...
            if [[ "$f" =~ ^backend/[^/]+/[^/]+/[^/]+/[^/]+/ ]]; then
              root="$(cut -d/ -f1-5 <<<"$f")"
              ROOTS["$root"]=1
              continue
            fi

            # frontend/{platform}/{type}/{solutionName}/...
            if [[ "$f" =~ ^frontend/[^/]+/[^/]+/[^/]+/ ]]; then
              root="$(cut -d/ -f1-4 <<<"$f")"
              ROOTS["$root"]=1
              continue
            fi
          done

          for root in "${!ROOTS[@]}"; do
            root="${root%/}"

            stack=""
            platform=""
            framework=""
            type=""
            solutionName=""

            if [[ "$root" =~ ^backend/([^/]+)/([^/]+)/([^/]+)/([^/]+)$ ]]; then
              stack="backend"
              platform="${BASH_REMATCH[1]}"
              framework="${BASH_REMATCH[2]}"
              type="${BASH_REMATCH[3]}"
              solutionName="${BASH_REMATCH[4]}"
            elif [[ "$root" =~ ^frontend/([^/]+)/([^/]+)/([^/]+)$ ]]; then
              stack="frontend"
              platform="${BASH_REMATCH[1]}"
              framework="$platform"
              type="${BASH_REMATCH[2]}"
              solutionName="${BASH_REMATCH[3]}"
            else
              continue
            fi

            item="$(jq -n \
              --arg stack "$stack" \
              --arg platform "$platform" \
              --arg framework "$framework" \
              --arg type "$type" \
              --arg solutionName "$solutionName" \
              --arg name "$solutionName" \
              --arg path "$root" \
              '{stack:$stack, platform:$platform, framework:$framework, type:$type, solutionName:$solutionName, name:$name, path:$path}')"

            solutions_json="$(jq -c --argjson item "$item" '. + [$item]' <<<"$solutions_json")"
            paths_json="$(jq -c --arg path "$root" '. + [$path]' <<<"$paths_json")"
          done

          # Sort + unique for stability
          solutions_json="$(jq -c 'sort_by(.path) | unique_by(.path)' <<<"$solutions_json")"
          paths_json="$(jq -c 'sort | unique' <<<"$paths_json")"

          echo "solutions=$solutions_json" >> "$GITHUB_OUTPUT"
          echo "paths=$paths_json" >> "$GITHUB_OUTPUT"

          echo "Discovered solutions:"
          jq . <<<"$solutions_json"