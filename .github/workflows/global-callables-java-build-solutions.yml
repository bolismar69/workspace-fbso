name: Global Callables Java Build Solutions

# FUNÇÃO
# - Build (Maven) + Docker build/push para serviços Java em monorepo.
# - Executa em matrix: cada item do JSON `services` vira um job da matrix.
# - Resolve blueprint (Dockerfile central + build args) via registries em `architecture/service_registry/*`.
# - Carrega variáveis compartilhadas de `.github/docker.env` e `.github/docker.java.env`.
#
# INPUTS (workflow_call)
# - services (obrigatório): string contendo JSON array, um item por serviço.
#   Formato oficial (campos obrigatórios para Java):
#   {
#     "path": "backend/java/<framework>/<type>/<name>",
#     "goals": "clean install",
#     "platformVersion": "21",
#     "platformDistributor": "temurin",
#     "docker": { "argCompilationMode": "jvm|native" }
#   }
#   Campos opcionais (override do parsing do path):
#   {"stack":"backend","platform":"java","framework":"spring|quarkus|generic","type":"...","name":"..."}
#
# Exemplo (caller)
#   services: |
#     [{"path":"backend/java/spring/microservices/ms-example","goals":"clean install","platformVersion":"21","platformDistributor":"temurin","docker":{"argCompilationMode":"jvm"}}]
#
# OUTPUTS (workflow_call)
# - Este workflow não define outputs. Efeito: publica imagem Docker (push) no registry configurado.

on:
  workflow_call:
    inputs:
      services:
        description: 'JSON array de objetos com os serviços a processar. Formato oficial: {"path":"...","goals":"...","platformVersion":"21","platformDistributor":"temurin","docker":{"argCompilationMode":"jvm|native"}}. Campos opcionais (override de parsing do path): {"stack":"backend","platform":"java","framework":"spring|quarkus|generic","type":"...","name":"..."}.'
        required: true
        type: string
    secrets:
      DOCKERHUB_USERNAME:
        required: true
      DOCKERHUB_TOKEN:
        required: true

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJSON(inputs.services) }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: ${{ matrix.platformDistributor }}
          java-version: ${{ matrix.platformVersion }}
          cache: maven

      - name: Carregar variáveis de ambiente compartilhadas (valida e exporta para passos seguintes)
        id: load_shared_env
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            function loadEnvFile(filePath) {
              if (!fs.existsSync(filePath)) {
                throw new Error(`${filePath} não encontrado`);
              }

              const raw = fs.readFileSync(filePath, 'utf8');
              const lines = raw.split('\n');

              for (const originalLine of lines) {
                const line = (originalLine ?? '').replace(/\r$/, '');
                const trimmed = line.trim();
                if (!trimmed || trimmed.startsWith('#')) continue;

                const eq = trimmed.indexOf('=');
                if (eq <= 0) {
                  core.warning(`Linha inválida ignorada em ${filePath}: ${trimmed}`);
                  continue;
                }

                const key = trimmed.slice(0, eq).trim();
                let value = trimmed.slice(eq + 1);

                // Pequena compatibilidade com placeholder comum do bash
                const sha = process.env.GITHUB_SHA || context.sha;
                value = value.replace(/\$\{GITHUB_SHA:0:7\}/g, sha.substring(0, 7));
                value = value.replace(/\$\{GITHUB_SHA\}/g, sha);

                core.exportVariable(key, value);
              }
            }

            loadEnvFile('.github/docker.env');
            loadEnvFile('.github/docker.java.env');

      - name: Resolver blueprint e build args
        id: resolve_blueprint
        uses: actions/github-script@v7
        env:
          MATRIX_PATH: ${{ matrix.path }}
          MATRIX_STACK: ${{ matrix.stack }}
          MATRIX_PLATFORM: ${{ matrix.platform }}
          MATRIX_FRAMEWORK: ${{ matrix.framework }}
          MATRIX_TYPE: ${{ matrix.type }}
          MATRIX_NAME: ${{ matrix.name }}
          MATRIX_PLATFORM_VERSION: ${{ matrix.platformVersion }}
          MATRIX_PLATFORM_COMPILATION_MODE: ${{ matrix.docker.argCompilationMode }}
          REGISTRY_FRAMEWORK_FILE: architecture/governance/config/global-frameworks.json
          REGISTRY_STACKTYPE_FILE: architecture/governance/config/global-types-solution.json
          REGISTRY_SOLUTIONS_FILE: architecture/governance/config/global-solutions.json
          DEFAULT_IMAGE_TO_BUILD_STANDARD: ${{ env.IMAGE_TO_BUILD_STANDARD }}
          DEFAULT_IMAGE_TO_BUILD_SPRING: ${{ env.IMAGE_TO_BUILD_SPRING }}
          DEFAULT_IMAGE_TO_BUILD_QUARKUS: ${{ env.IMAGE_TO_BUILD_QUARKUS }}
          DEFAULT_IMAGE_TO_RUNTIME_JVM: ${{ env.IMAGE_TO_RUNTIME_JVM }}
          DEFAULT_IMAGE_TO_RUNTIME_NATIVE: ${{ env.IMAGE_TO_RUNTIME_NATIVE }}
          DEFAULT_PORT_TO_EXPOSE: ${{ env.PORT_TO_EXPOSE }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            function readJson(filePath) {
              if (!fs.existsSync(filePath)) {
                throw new Error(`Arquivo de registry não encontrado: ${filePath}`);
              }
              try {
                return JSON.parse(fs.readFileSync(filePath, 'utf8'));
              } catch (err) {
                throw new Error(`Falha ao parsear JSON: ${filePath}`);
              }
            }

            function isObject(value) {
              return value && typeof value === 'object' && !Array.isArray(value);
            }

            function deepMerge(base, override) {
              if (!isObject(base)) base = {};
              if (!isObject(override)) return base;
              const out = { ...base };
              for (const [key, value] of Object.entries(override)) {
                if (isObject(value) && isObject(out[key])) {
                  out[key] = deepMerge(out[key], value);
                } else {
                  out[key] = value;
                }
              }
              return out;
            }

            const matrixPath = (process.env.MATRIX_PATH ?? '').toString();
            if (!matrixPath) throw new Error('MATRIX_PATH vazio');

            // Overrides opcionais via matrix (não obrigatórios)
            const stackOverride = (process.env.MATRIX_STACK ?? '').toString().trim();
            const platformOverride = (process.env.MATRIX_PLATFORM ?? '').toString().trim();
            const frameworkOverride = (process.env.MATRIX_FRAMEWORK ?? '').toString().trim();
            const typeOverride = (process.env.MATRIX_TYPE ?? '').toString().trim();
            const nameOverride = (process.env.MATRIX_NAME ?? '').toString().trim();
            const platformModeOverride = (process.env.MATRIX_PLATFORM_COMPILATION_MODE ?? '').toString().trim();
            const platformVersionOverrideRaw = (process.env.MATRIX_PLATFORM_VERSION ?? '').toString().trim();

            // Esperado no path: backend/java/<framework>/<type>/<service>
            const parts = matrixPath.split('/').filter(Boolean);
            if (parts.length < 5) {
              throw new Error(`Caminho inesperado (precisa de 5+ segmentos): ${matrixPath}`);
            }

            let [stack, platform, framework, stackType, name] = parts;
            if (stackOverride) stack = stackOverride;
            if (platformOverride) platform = platformOverride;
            if (frameworkOverride) framework = frameworkOverride;
            if (typeOverride) stackType = typeOverride;
            if (nameOverride) name = nameOverride;

            const fwFile = process.env.REGISTRY_FRAMEWORK_FILE;
            const stFile = process.env.REGISTRY_STACKTYPE_FILE;
            const solFile = process.env.REGISTRY_SOLUTIONS_FILE;

            const fwJson = readJson(fwFile);
            const stJson = readJson(stFile);
            const solJson = readJson(solFile);

            // NOVO: schemas antigos blueprint* não são mais suportados.
            const fwEntries = fwJson.globalFramework;
            const stEntries = stJson.globalTypeSolution;
            const solEntries = solJson.globalSolution;

            if (!Array.isArray(fwEntries)) {
              throw new Error(`Schema inválido em ${fwFile}. Esperado array em 'globalFramework'.`);
            }
            if (!Array.isArray(stEntries)) {
              throw new Error(`Schema inválido em ${stFile}. Esperado array em 'globalTypeSolution'.`);
            }
            if (!Array.isArray(solEntries)) {
              throw new Error(`Schema inválido em ${solFile}. Esperado array em 'globalSolution'.`);
            }

            const fwLabel = 'globalFramework';
            const stLabel = 'globalTypeSolution';
            const solLabel = 'globalSolution';

            function findOne(list, predicate, label) {
              const matches = list.filter(predicate);
              if (matches.length > 1) {
                core.warning(`Mais de uma entrada encontrada em ${label}; usando a primeira. total=${matches.length}`);
              }
              return matches[0] ?? null;
            }

            const frameworkCfg = findOne(
              fwEntries,
              (e) => e?.stack === stack && e?.platform === platform && e?.framework === framework,
              fwLabel
            );
            const typeCfg = findOne(
              stEntries,
              (e) => e?.stack === stack && e?.platform === platform && e?.framework === framework && e?.type === stackType,
              stLabel
            );
            const solutionCfg = findOne(
              solEntries,
              (e) => e?.stack === stack && e?.platform === platform && e?.framework === framework && e?.type === stackType && e?.name === name,
              solLabel
            );

            if (!frameworkCfg) {
              const availableFrameworks = Array.from(
                new Set(
                  fwEntries
                    .filter((e) => e?.stack === stack && e?.platform === platform)
                    .map((e) => (e?.framework ?? '').toString())
                    .filter(Boolean)
                )
              ).sort();

              throw new Error(
                `Sem configuração no registry (${fwLabel}) para {stack/platform/framework} = {${stack}/${platform}/${framework}}. ` +
                `Frameworks disponíveis para {${stack}/${platform}}: ${availableFrameworks.join(', ') || '(nenhum)'}`
              );
            }

            let merged = {};
            merged = deepMerge(merged, frameworkCfg);
            merged = deepMerge(merged, typeCfg || {});
            merged = deepMerge(merged, solutionCfg || {});

            // platformVersion: mantemos como MAJOR para naming de Dockerfile/build args
            // (o setup-java usa um version string mais específico via tabela padronizada)
            let platformVersionMajor = merged.platformVersion ?? 21;
            if (platformVersionOverrideRaw) {
              const major = Number(String(platformVersionOverrideRaw).split('.')[0]);
              if (Number.isFinite(major) && major > 0) {
                platformVersionMajor = major;
              } else {
                core.warning(`MATRIX_PLATFORM_VERSION inválido (${platformVersionOverrideRaw}); usando platformVersion do registry=${platformVersionMajor}`);
              }
            }

            let platformMode = (merged.platformMode ?? 'jvm').toString();
            if (platformModeOverride) {
              platformMode = platformModeOverride;
            }

            // Dockerfile central esperado
            // Preferência: Dockerfile.<mode>.<version> (novo padrão)
            // Fallback:    Dockerfile.<version> (padrão legado já existente no repo)
            // ANTIGA: const dockerfilePreferred = `architecture/blueprints/${stack}/${platform}/${framework}/docker/Dockerfile.${platformMode}.${platformVersionMajor}`;
            const dockerfilePreferred = `architecture/blueprints/${stack}/${platform}/${framework}/${stackType}/v${platformVersionMajor}/Dockerfile.${platformMode}.${platformVersionMajor}`;
            // ANTIGA: const dockerfileLegacy = `architecture/blueprints/${stack}/${platform}/${framework}/docker/Dockerfile.${platformVersionMajor}`;
            const dockerfileLegacy = `architecture/blueprints/${stack}/${platform}/${framework}/${stackType}/v${platformVersionMajor}/Dockerfile.${platformVersionMajor}`;
            const dockerfile = fs.existsSync(dockerfilePreferred)
              ? dockerfilePreferred
              : (fs.existsSync(dockerfileLegacy) ? dockerfileLegacy : null);
            if (!dockerfile) {
              throw new Error(`Dockerfile central não encontrado. Tentativas: ${dockerfilePreferred} | ${dockerfileLegacy}`);
            }

            // Defaults (se não vier do registry)
            const defaultBuildByFramework = {
              spring: process.env.DEFAULT_IMAGE_TO_BUILD_SPRING,
              quarkus: process.env.DEFAULT_IMAGE_TO_BUILD_QUARKUS,
              generic: process.env.DEFAULT_IMAGE_TO_BUILD_STANDARD,
            };
            const defaultRuntimeByMode = {
              jvm: process.env.DEFAULT_IMAGE_TO_RUNTIME_JVM,
              native: process.env.DEFAULT_IMAGE_TO_RUNTIME_NATIVE,
            };

            const dockerCfg = merged.docker ?? {};
            const imageBuild = dockerCfg.argImageBuild || defaultBuildByFramework[framework] || process.env.DEFAULT_IMAGE_TO_BUILD_STANDARD;
            const imageRuntime = dockerCfg.argImageRuntime || defaultRuntimeByMode[platformMode] || process.env.DEFAULT_IMAGE_TO_RUNTIME_JVM;
            const exposePort = dockerCfg.argExposePort ?? (process.env.DEFAULT_PORT_TO_EXPOSE ? Number(process.env.DEFAULT_PORT_TO_EXPOSE) : 8080);

            const cmdExtraBuilderPreCopy = (dockerCfg.argCmdExtraBuilderPreCopy ?? '').toString();
            const cmdExtraBuilderPosCompile = (dockerCfg.argCmdExtraBuilderPosCompile ?? '').toString();
            const cmdExtraRuntimePreCopy = (dockerCfg.argCmdExtraRuntimePreCopy ?? '').toString();
            const cmdExtraRuntimePreCmd = (dockerCfg.argCmdExtraRuntimePreCmd ?? '').toString();

            core.info(`Blueprint resolvido: ${stack}/${platform}/${framework}/${stackType}/${name}`);
            core.info(`Dockerfile central: ${dockerfile}`);
            core.info(`platformVersion(major)=${platformVersionMajor}, platformMode=${platformMode}`);

            core.setOutput('dockerfile', dockerfile);
            core.setOutput('java_version', String(platformVersionMajor));
            core.setOutput('platform_mode', platformMode);
            core.setOutput('image_to_build', imageBuild);
            core.setOutput('image_to_runtime', imageRuntime);
            core.setOutput('app_port', String(exposePort));
            core.setOutput('cmd_extra_builder_pre_copy', cmdExtraBuilderPreCopy);
            core.setOutput('cmd_extra_builder_pos_compile', cmdExtraBuilderPosCompile);
            core.setOutput('cmd_extra_runtime_pre_copy', cmdExtraRuntimePreCopy);
            core.setOutput('cmd_extra_runtime_pre_cmd', cmdExtraRuntimePreCmd);

      - name: Definir caminho sanitizado
        id: sanitize_path
        uses: actions/github-script@v7
        env:
          MATRIX_PATH: ${{ matrix.path }}
        with:
          script: |
            const matrixPath = (process.env.MATRIX_PATH ?? '').toString();
            if (!matrixPath) throw new Error('MATRIX_PATH vazio');

            const parts = matrixPath.split('/').filter(Boolean);
            const baseName = parts[parts.length - 1] || matrixPath;
            const sanitized = baseName.replace(/\//g, '-');

            core.exportVariable('SANITIZED_PATH', sanitized);

      - name: Cache do Maven
        id: cache_maven
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-maven-${{ env.SANITIZED_PATH }}-${{ hashFiles(format('{0}/**/pom.xml', matrix.path)) }}
          restore-keys: ${{ runner.os }}-maven-

      - name: Cache OWASP Dependency-Check DB
        uses: actions/cache@v4
        with:
          path: ~/.dependency-check
          key: ${{ runner.os }}-dependency-check-${{ github.ref_name }}
          restore-keys: |
            ${{ runner.os }}-dependency-check-

      - name: Build do serviço com Maven (usa mvnm quando disponivel)
        env:
          NVD_API_KEY: ${{ secrets.NVD_API_KEY }}
        run: |
          set -euo pipefail
          cd ${{ matrix.path }}
          if [ -x ./mvnw ]; then
            ./mvnw ${{ matrix.goals }}
          else
            mvn -B -U verify -Ddependency-check.skip=true
          fi

      - name: Validar artefato gerado
        id: validate_artifact
        run: |
          set -euo pipefail
          cd ${{ matrix.path }}
          if compgen -G "target/*.jar" > /dev/null; then
            echo "OK - artifact JAR encontrado"
          elif [ -d target ] && [ "$(ls -A target)" ]; then
            echo "OK - diretório target contém arquivos"
          else
            echo "Artifact ausente em ${{ matrix.path }}" >&2
            ls -la || true
            exit 1
          fi

      - name: Preparar Docker Buildx
        id: setup_buildx
        uses: docker/setup-buildx-action@v2

      - name: Login no registry Docker
        id: docker_login
        uses: docker/login-action@v2
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Definir IMAGE_NAME e IMAGE_TAG
        id: define_image
        uses: actions/github-script@v7
        env:
          MATRIX_PATH: ${{ matrix.path }}
          DOCKER_REGISTRY: ${{ env.DOCKER_REGISTRY }}
          DOCKER_ORG: ${{ env.DOCKER_ORG }}
          DOCKER_TAG_PREFIX: ${{ env.DOCKER_TAG_PREFIX }}
          GITHUB_SHA: ${{ github.sha }}
        with:
          script: |
            const matrixPath = (process.env.MATRIX_PATH ?? '').toString();
            if (!matrixPath) throw new Error('MATRIX_PATH vazio');

            const parts = matrixPath.split('/').filter(Boolean);
            const imageName = parts[parts.length - 1] || matrixPath;
            core.exportVariable('IMAGE_NAME', imageName);

            const registry = (process.env.DOCKER_REGISTRY ?? '').toString();
            const org = (process.env.DOCKER_ORG ?? '').toString();
            const prefix = (process.env.DOCKER_TAG_PREFIX ?? 'ci').toString();
            const sha = (process.env.GITHUB_SHA ?? context.sha).toString();

            if (!registry || !org) {
              throw new Error('DOCKER_REGISTRY/DOCKER_ORG não definidos');
            }

            const imageTag = `${registry}/${org}/${imageName}:${prefix}-${sha}`;
            core.exportVariable('IMAGE_TAG', imageTag);

      - name: Build & Push com build-push-action
        id: buildpush
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ${{ steps.resolve_blueprint.outputs.dockerfile }}
          push: true
          tags: ${{ env.IMAGE_TAG }}
          build-args: |
            SERVICE_PATH=${{ matrix.path }}
            JAVA_VERSION=${{ steps.resolve_blueprint.outputs.java_version }}
            IMAGE_TO_BUILD=${{ steps.resolve_blueprint.outputs.image_to_build }}
            IMAGE_TO_RUNTIME=${{ steps.resolve_blueprint.outputs.image_to_runtime }}
            APP_PORT=${{ steps.resolve_blueprint.outputs.app_port }}
            CMD_EXTRA_BUILDER_PRE_COPY=${{ steps.resolve_blueprint.outputs.cmd_extra_builder_pre_copy }}
            CMD_EXTRA_BUILDER_POS_COMPILE=${{ steps.resolve_blueprint.outputs.cmd_extra_builder_pos_compile }}
            CMD_EXTRA_RUNTIME_PRE_COPY=${{ steps.resolve_blueprint.outputs.cmd_extra_runtime_pre_copy }}
            CMD_EXTRA_RUNTIME_PRE_CMD=${{ steps.resolve_blueprint.outputs.cmd_extra_runtime_pre_cmd }}
